## 👣 前端发展的几个时代

### 🚌 附属时代

 ⽹⻚是静态的，并没有前端和后端之分。前端开发的⼯作⽐较简单，主要是 对⽂字、图⽚做排版和样式修饰，并没有⾮常复杂的交互。  

> jQuery 实现交互

 前端的“技术性”体现在 jQuery 上。 jQuery 创造了⼀个代替原⽣ API 的东⻄，⽽是将原⽣ API 包装起来，采⽤⼀种更简单、直观 的⽅式实现调⽤。  

 jQuery 最强⼤的功能还是插件系统——可以将⼀个功能模块封装成插件以供复⽤。

### **🎢** 分家时代

>  前端和后端⼀体开发的弊端逐渐暴露出来，具体表现在以下两个⽅⾯：  
>
>  +  模块划分：项⽬代码⽇渐庞⼤臃肿，开发者意识到必须通过拆分模块来降低代码的耦合度。然 ⽽⼤部分的视图代码都是前端和后端混在⼀起的，难以解耦； 
>  +  多⼈协作：项⽬越⼤，开发者就越多，前端和后端的开发者在⼀个代码仓库中不断拉取与合 并，这本身就是不规范的，很容易引发冲突和覆盖的问题。

####  AJAX 出现

 AJAX 为 JavaScript 带来了异步获取数据的能⼒。这种异步获取数据的能⼒使“不刷新浏览器更新⻚⾯状 态”成为可能。

 随后 AJAX 不断在前端中创造价值，如按需加载⽂件，甚⾄多客户端之间的异步通信，让前 端在⼀个⻚⾯中与后端交互变得⾮常流⾏。

####  前后端分离  

+  **路由问题**。AJAX 局部更新可以动态改变⻚⾯，但并不会导致 URL 地址发⽣变化。最终的结 果可能是经过多次操作切换到某个⻚⾯，结果⼀刷新，⻚⾯⼜切换到最开始的位置；
+  **状态问题**。在后端渲染的 MVC 模式下，⽤户信息被存储在 Session 中，当前⽤户的登录状 态可以直接得到。但在纯前端的环境下，应⽤是⽆状态的，如何处理⽤户登录就成了难题。

####  三⼤框架出现并流⾏

>  AngularJS、 React、Vue.js

+  **AngularJS**在框架中引⼊ 了 MVC，依赖注⼊和模块化的设计思想。 AngularJS 并不依赖操作 DOM 来更新⻚⾯，⽽是提供了⼀个很超前 的⽅法，即双向数据绑定。只要把数据绑定到 HTML 上，在数据发⽣改变时，绑定的数据就会 ⾃动更新。这是最早的数据驱动视图的思想。 
+  **React** 在吸收了 AngularJS 精华的基础上，⼜创造了虚拟 DOM（Virtual DOM），⼀下⼦突破了复杂⻚⾯的性能 瓶颈。另外，React 还提供了创新性的 JSX 语法和 Diff 算法。
+  **Vue.js **吸收了 AngularJS 和 React 的精华，不仅 采⽤虚拟 DOM，还保留了双向绑定。 最重要的是，Vue.js 的 API 设计⾮常简单，很容易上⼿， 因此吸引了⼤批的开发者使⽤。另外，Vue.js 的开发⽂档对国内程序员⾮常友好，中⽂表述简 单，读起来毫不费劲。 

### ✈️ 工程化时代

####  Node.js 开启了前端⼯程  

 Node.js 通过⽂件 API ⽣成项⽬，同时创建本地服务器 挂载前端项⽬，使前端项⽬始终处在 Node.js 的运⾏环境之下。 有了 Node.js 的运⾏环境，前端开发者就可以充分发挥想象⼒，将服务端领域的先进理念迁 移到前端。

>  什么是前端⼯程化？主流的前端⼯程化是将 Node.js 的功能投射到前端项⽬上，为前端安装各种“装备”，从⽽彻底提⾼前端开发者的开发 效率。

####  Webpack 带来了编译

  Webpack 是⼀个现代的 JavaScript 应⽤程序的打包器。它有两⽅⾯的核⼼作⽤，分别是打 包盒转换。

+ 打包：意味着 Webpack 可以将任意⽂件模块化，从⽽在项⽬中可以通过 import/export 实 现⽂件的导⼊导出； 
+ 转换：意味着对于 Webpack 不认识的⾮ JavaScript ⽂件，通过⾃定义的 Loader 让 Webpack 认识并处理这个⽂件。

>    正因为出现了编译，前端才有了“源码”和“可执⾏代码”的区别。

####  ⼯程化体系持续完善

+ **Babel**：负责转换 Javascript 语法。它⾯向 JavaScript，可以将最新的 Javascript 语法转换 成 ES5 的标准语法，让绝⼤部分的浏览器⽀持。可以说，有了 Babel，就不⽤担⼼兼容性， 可以放⼼使⽤最先进的语法； 
+ **Less/Sass**：负责⽣成 CSS 代码。它解决了⼤部分纯 CSS 不够友好的问题，如⽀持嵌套语 法、定义变量，从⽽使开发效率和编码体验得到成倍的提升。预处理经过编译后，会转换为普 通的 CSS 样式，在 Webpack 中，它们有各⾃的 loader 来实现代码的转换； 
+ **ESLint**：负责检测代码规范。它具有代码规范和检测代码规范两⼤功能。定义代码规范包括 使⽤单引号还是双引号，代码末尾要不要使⽤分号，以及什么时候换⾏等代码⻛格类的规范。 在多⼈团队协作中，代码规范⾮常重要，但往往每个⼈的编码⻛格不同，导致规范难以统⼀， 有了 ESLint 的规范检测和格式化，就能很容易地解决这个问题。

### 🚀 大前端时代

####   跨端开发成为趋势

 ⼀些优 秀的解决⽅案逐渐浮出⽔⾯，并选择在社区开源。例如，UniApp、Taro、React Native、 Electron、Flutter 等跨端⽅案被⼴泛应⽤，前端有机会从“开发⼀端”转变为“开发多端”。

####  ⼀处代码，多处运⾏

>   多端开发的现状和 JavaScript 的优势，催⽣了以 JavaScript 为主的跨端解决⽅案，其中有 代表性的包括 UniApp、Taro、React Native、Electron、Flutter 等。  

+  **UniApp**： UniApp 是⼀款创新的跨平台开发框架，它以 Vue.js 的语法为核⼼，允许开发者编写⼀次代 码，便能编译运⾏在iOS、Android、Web等不同平台上。 它不仅⽀持 Vue 的所有特性，如组件化、数据绑定和事件处理，还 提供了⼀套完整的 API 来访问设备的功能，如摄像头、位置服务等。UniApp 还提供了⼀套易于使⽤的 UI 组件库，帮助开发者快速构建美观且功能丰富的 ⽤户界⾯。
+  ** Taro： **Taro 是⼀个使⽤ React 语法的跨端开发框架，在编译时期将 React DSL 转换为各端代码， 从⽽实现“⼀码多端”。 Taro 3 ⽀持直接引⽤ Vue.js/React 框架本身的代码。Taro 只做渲染层的逻辑，这就解决了 语法兼容问题。因此，Taro 3 ⽀持同时⽤ React 语法和 Vue.js 语法进⾏开发，从根本上解决了 与 Web 代码隔离的问题。  
+  **React Native： **React Native 也沿⽤了 React 框架中的虚拟 DOM ⽅案：只需要编写⼀套代码，就可以将代 码打包成不同平台的 App，这极⼤地提⾼了开发效率。
+  ** Electron： **Electron 是开发桌⾯端应⽤的框架， Electron 框架内部嵌⼊了 Chromium 和 Node.js。Chromium 负责界⾯的渲染，所以应⽤窗 ⼝像 Chrome 浏览器；Node.js 主要关注逻辑部分，负责系统底层能⼒的调⽤。
+  **Flutter**： Flutter 提供了丰富的组件、接⼝，开发者可以很快地为 Flutter 添加 Native （即原⽣开发）来开发应⽤，可以和平台原⽣语⾔混合开发扩展。

### 🌏 Serverless时代

####  **函数即服务**

 函数即服务（FaaS）是⼀种⾯向函数构建和部署软件的⽅式，即云函数，是 Serverless 的最 终表现形式。以前前端的函数是“本地声明，本地调⽤”。现在云函数单独部署在云上，供前端远 程调⽤。

#### **前后端⼀体化开发**

 Faas 带来的开发模式的变⾰，使创建后端服务像创建⼀个函数那样简单。在这种“⽆服务”的 状态下，前端会发⽣⼀次颠覆性的变⾰。 前端开发者除了担负传统的界⾯开发，还要担负数据库管理的⼯作（编写 云函数操作数据），此时不再由后端提供接⼝，数据对接需要前端开发者⾃⼰开发和调试，这就要 求每个前端开发者必须有全栈开发的能⼒。  